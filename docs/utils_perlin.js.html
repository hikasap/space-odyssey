<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils/perlin.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils/perlin.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Class representing 3D Perlin noise generator.
 */
export class Perlin {
    /**
     * Create a Perlin noise generator.
     * @param {number} [frequency=1.0] - Frequency of the noise. Controls the scale of the noise.
     * @param {number} [amplitude=1.0] - Amplitude of the noise. Controls the strength of the noise.
     * 
     * @example
     * const perlin = new Perlin(2.0, 0.5);
     * const noiseValue = perlin.noise(10, 20, 30);
     * console.log('Noise Value:', noiseValue);
     */
    constructor(frequency = 1.0, amplitude = 1.0) {
        /**
         * Frequency of the noise.
         * @type {number}
         */
        this.frequency = frequency;

        /**
         * Amplitude of the noise.
         * @type {number}
         */
        this.amplitude = amplitude;

        /**
         * Gradients for 3D Perlin noise.
         * @type {Array&lt;Array&lt;number>>}
         * @private
         */
        this.grad3 = [
            [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
            [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],
            [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1],
        ];

        /**
         * Permutation array.
         * @type {Array&lt;number>}
         * @private
         */
        this.p = [];
        for (let i = 0; i &lt; 256; i++) {
            this.p[i] = Math.floor(Math.random() * 256);
        }

        /**
         * Extended permutation array for noise generation.
         * @type {Array&lt;number>}
         * @private
         */
        this.perm = [];
        for (let i = 0; i &lt; 512; i++) {
            this.perm[i] = this.p[i &amp; 255];
        }
    }

    /**
     * Computes the dot product of a gradient and a position vector.
     * @param {Array&lt;number>} g - Gradient vector.
     * @param {number} x - X-coordinate.
     * @param {number} y - Y-coordinate.
     * @param {number} z - Z-coordinate.
     * @returns {number} Dot product result.
     * @private
     */
    dot(g, x, y, z) {
        return g[0] * x + g[1] * y + g[2] * z;
    }

    /**
     * Generates raw 3D Perlin noise for given coordinates.
     * @param {number} x - X-coordinate.
     * @param {number} [y=0] - Y-coordinate.
     * @param {number} [z=0] - Z-coordinate.
     * @returns {number} Raw Perlin noise value.
     */
    rawNoise(x, y = 0, z = 0) {
        const F3 = 1 / 3, G3 = 1 / 6;
        let n0, n1, n2, n3;
        let s = (x + y + z) * F3;
        let i = Math.floor(x + s);
        let j = Math.floor(y + s);
        let k = Math.floor(z + s);
        let t = (i + j + k) * G3;
        let X0 = i - t, Y0 = j - t, Z0 = k - t;
        let x0 = x - X0, y0 = y - Y0, z0 = z - Z0;

        let i1, j1, k1;
        let i2, j2, k2;
        if (x0 >= y0) {
            if (y0 >= z0) {
                i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0;
            } else if (x0 >= z0) {
                i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1;
            } else {
                i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1;
            }
        } else {
            if (y0 &lt; z0) {
                i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1;
            } else if (x0 &lt; z0) {
                i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1;
            } else {
                i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0;
            }
        }

        let x1 = x0 - i1 + G3, y1 = y0 - j1 + G3, z1 = z0 - k1 + G3;
        let x2 = x0 - i2 + 2 * G3, y2 = y0 - j2 + 2 * G3, z2 = z0 - k2 + 2 * G3;
        let x3 = x0 - 1 + 3 * G3, y3 = y0 - 1 + 3 * G3, z3 = z0 - 1 + 3 * G3;

        i &amp;= 255; j &amp;= 255; k &amp;= 255;
        let gi0 = this.perm[i + this.perm[j + this.perm[k]]] % 12;
        let gi1 = this.perm[i + i1 + this.perm[j + j1 + this.perm[k + k1]]] % 12;
        let gi2 = this.perm[i + i2 + this.perm[j + j2 + this.perm[k + k2]]] % 12;
        let gi3 = this.perm[i + 1 + this.perm[j + 1 + this.perm[k + 1]]] % 12;

        let t0 = 0.5 - x0 * x0 - y0 * y0 - z0 * z0;
        if (t0 &lt; 0) { n0 = 0; } else {
            t0 *= t0;
            n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0, z0);
        }
        let t1 = 0.5 - x1 * x1 - y1 * y1 - z1 * z1;
        if (t1 &lt; 0) { n1 = 0; } else {
            t1 *= t1;
            n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1, z1);
        }
        let t2 = 0.5 - x2 * x2 - y2 * y2 - z2 * z2;
        if (t2 &lt; 0) { n2 = 0; } else {
            t2 *= t2;
            n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2, z2);
        }
        let t3 = 0.5 - x3 * x3 - y3 * y3 - z3 * z3;
        if (t3 &lt; 0) { n3 = 0; } else {
            t3 *= t3;
            n3 = t3 * t3 * this.dot(this.grad3[gi3], x3, y3, z3);
        }
        return 72 * (n0 + n1 + n2 + n3);
    }

    /**
     * Generates 3D Perlin noise with applied frequency and amplitude.
     * @param {number} x - X-coordinate.
     * @param {number} [y=0] - Y-coordinate.
     * @param {number} [z=0] - Z-coordinate.
     * @returns {number} Perlin noise value.
     */
    noise(x, y = 0, z = 0) {
        return this.amplitude * this.rawNoise(x * this.frequency, y * this.frequency, z * this.frequency);
    }

    /**
     * Generates fractal noise (fBM) using multiple octaves.
     * @param {number} x - X-coordinate.
     * @param {number} [y=0] - Y-coordinate.
     * @param {number} [z=0] - Z-coordinate.
     * @param {number} [octaves=4] - Number of octaves to use.
     * @param {number} [lacunarity=2] - Frequency multiplier for each octave.
     * @param {number} [gain=0.5] - Amplitude multiplier for each octave.
     * @returns {number} Fractal noise value.
     */
    fractalNoise(x, y = 0, z = 0, octaves = 4, lacunarity = 2, gain = 0.5) {
        let sum = 0;
        let freq = this.frequency;
        let amp = this.amplitude;

        for (let o = 0; o &lt; octaves; o++) {
            sum += this.rawNoise(x * freq, y * freq, z * freq) * amp;
            freq *= lacunarity;
            amp *= gain;
        }
        return sum;
    }
}

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-NameGenerator.html">NameGenerator</a></li></ul><h3>Classes</h3><ul><li><a href="Asteroid.html">Asteroid</a></li><li><a href="FuelManager.html">FuelManager</a></li><li><a href="GameConfig.html">GameConfig</a></li><li><a href="GameConfig_GameConfig.html">GameConfig</a></li><li><a href="Perlin.html">Perlin</a></li></ul><h3>Global</h3><ul><li><a href="global.html#createGoldbergPolyhedron">createGoldbergPolyhedron</a></li><li><a href="global.html#getIntersectedObject">getIntersectedObject</a></li><li><a href="global.html#setSeed">setSeed</a></li><li><a href="global.html#setupInteraction">setupInteraction</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Tue Jan 21 2025 08:43:53 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
